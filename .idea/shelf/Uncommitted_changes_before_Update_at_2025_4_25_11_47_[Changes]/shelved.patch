Index: EIMP/src/main/java/com/eimp/controller/WindowSlideController.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package com.eimp.controller;\r\nimport com.eimp.SlideWindow;\r\nimport com.eimp.component.ImageInfoPane;\r\nimport com.eimp.util.FileUtil;\r\nimport com.eimp.util.ImageUtil;\r\nimport javafx.animation.*;\r\nimport javafx.application.Platform;\r\nimport javafx.beans.property.IntegerProperty;\r\nimport javafx.beans.property.SimpleIntegerProperty;\r\nimport javafx.collections.FXCollections;\r\nimport javafx.collections.ObservableList;\r\nimport javafx.event.ActionEvent;\r\nimport javafx.event.Event;\r\nimport javafx.event.EventHandler;\r\nimport javafx.fxml.FXML;\r\nimport javafx.fxml.Initializable;\r\nimport javafx.geometry.Bounds;\r\nimport javafx.geometry.Point2D;\r\nimport javafx.geometry.Pos;\r\nimport javafx.scene.Cursor;\r\nimport javafx.scene.Node;\r\nimport javafx.scene.Scene;\r\nimport javafx.scene.control.*;\r\nimport javafx.scene.image.Image;\r\nimport javafx.scene.image.ImageView;\r\nimport javafx.scene.input.*;\r\nimport javafx.scene.layout.*;\r\nimport javafx.scene.transform.Rotate;\r\nimport javafx.stage.Stage;\r\nimport javafx.util.Duration;\r\nimport org.controlsfx.control.Notifications;\r\nimport java.io.File;\r\nimport java.net.URL;\r\nimport java.util.*;\r\n\r\n\r\npublic class WindowSlideController implements Initializable {\r\n    /**\r\n     * 所属窗口stage\r\n     */\r\n    private Stage stage;\r\n    /**\r\n     * 主照片视图\r\n     */\r\n    @FXML private ImageView mainImageView;\r\n    /**\r\n     * 图片缩略图栏容器\r\n     */\r\n    @FXML private HBox thumbnailContainer;\r\n    @FXML private Button rotate;\r\n    @FXML private Button delete;\r\n    @FXML private Button prePage;\r\n    @FXML private Button nextPage;\r\n    @FXML private Button play;\r\n    @FXML private Button info;\r\n    @FXML private Button compress;\r\n    /**\r\n     * 图片放大按钮\r\n     */\r\n    @FXML private Button zoomIn;\r\n    /**\r\n     * 图片缩小按钮\r\n     */\r\n    @FXML private Button zoomOut;\r\n    /**\r\n     * 图片放缩比例\r\n     */\r\n    @FXML private Label zoomScale;\r\n    /**\r\n     * 恢复图片原始比例按钮\r\n     */\r\n    @FXML private Button originalScale;\r\n    /**\r\n     * 窗口关闭按钮\r\n     */\r\n    @FXML private Button closeBtn;\r\n    /**\r\n     * 窗口最小化按钮\r\n     */\r\n    @FXML private Button minBtn;\r\n    /**\r\n     * 全屏按钮\r\n     */\r\n    @FXML private Button maxBtn;\r\n    private URL location;\r\n    private ResourceBundle resources;\r\n    /**\r\n     * 顶部主功能按钮栏,动态伸缩\r\n     */\r\n    @FXML private HBox dynamicButtonContainer;\r\n    /**\r\n     * ID与图标映射关系\r\n     */\r\n    private Map<String,String> urlMap = new HashMap<>();\r\n    /**\r\n     * ID与提示文本映射关系\r\n     */\r\n    private Map<String,String> textMap = new HashMap<>();\r\n    /**\r\n     * ID与顶部功能按钮映射关系\r\n     */\r\n    private Map<String,Button> buttonMap = new HashMap<>();\r\n    /**\r\n     * 更多功能按钮\r\n      */\r\n    @FXML\r\n    private Button moreMenuButton;\r\n    /**\r\n     * 当前图片的信息工具\r\n     */\r\n    private ImageUtil imageUtil;\r\n    /**\r\n     * 当前图片\r\n     */\r\n    private Image image;\r\n    /**\r\n     * 当前文件夹的图片列表\r\n     */\r\n    private ObservableList<ImageUtil> imageUtilList = FXCollections.observableArrayList();\r\n    /**\r\n     * 当前图片索引\r\n     */\r\n    private IntegerProperty currentIndex = new SimpleIntegerProperty(0);\r\n    /**\r\n     * 主窗口控制器\r\n     */\r\n    private WindowMainController windowMainController;\r\n    /**\r\n     * 用于控制持续触发事件的时间线\r\n     */\r\n    private Timeline timeline;\r\n    /**\r\n     * 幻灯片播放时间线\r\n     */\r\n    private Timeline playingTimeLine;\r\n    /**\r\n     * 图片放缩时间线\r\n     */\r\n    private Timeline zoomingTimeLine;\r\n    /**\r\n     * 图片显示模式枚举值\r\n     */\r\n    private enum DisplayMode {FIT, ORIGINAL, ZOOMING};\r\n    /**\r\n     * 初始图片显示模式\r\n     */\r\n    private DisplayMode displayMode = DisplayMode.FIT;\r\n    /**\r\n     * 图片放缩比例\r\n     */\r\n    private IntegerProperty scaleInteger = new SimpleIntegerProperty(-1);\r\n    /**\r\n     * 最大比例\r\n     */\r\n    private final int MAX_SCALE = 5000;\r\n    /**\r\n     * 最小比例\r\n     */\r\n    private  int MIN_SCALE;\r\n    /**\r\n     * 图片面板\r\n     */\r\n    @FXML\r\n    private StackPane imagePane;\r\n    /**\r\n     * 缩略图栏面板\r\n     */\r\n    @FXML\r\n    private AnchorPane secondaryPane;\r\n    /**\r\n     * 图片名标签\r\n     */\r\n    @FXML\r\n    private Label imageName;\r\n    /**\r\n     * 图片索引提示按钮\r\n     */\r\n    @FXML\r\n    private Button orderNum;\r\n    /**\r\n     * 图片大小提示按钮\r\n     */\r\n    @FXML\r\n    private Button fileSize;\r\n    /**\r\n     * 图片尺寸提示按钮\r\n     */\r\n    @FXML\r\n    private Button imageArea;\r\n    /**\r\n     * 图片宽高\r\n     */\r\n    private double originalWidth, originalHeight;\r\n    @FXML private HBox infoColumn;\r\n    /**\r\n     * 窗口布局初始化,对fxml布局组件初始化\r\n     * @param location\r\n     * @param resources\r\n     */\r\n    @Override\r\n    public void initialize(URL location, ResourceBundle resources) {\r\n        this.location = location;\r\n        this.resources = resources;\r\n        this.windowMainController = (WindowMainController) ControllerMap.getController(WindowMainController.class);\r\n        this.stage = SlideWindow.getStage();\r\n\r\n        this.initMap();\r\n        this.initMoreMenuButton();\r\n        this.setUpDynamicButtonContainerListener();\r\n        this.initButtonStyle();\r\n        this.setUpWindowControls();\r\n        this.initImageInfoPane();\r\n        this.setUpFullScreenListener();\r\n//        this.secondaryPane.setVisible(false);// 暂时隐藏缩略图栏,待实现\r\n    }\r\n\r\n    /**\r\n     * 设置全屏监听器\r\n     */\r\n    private void setUpFullScreenListener(){\r\n        stage.fullScreenProperty().addListener((obs,wasFullScreen,isNowFullScreen) -> {\r\n            if(isNowFullScreen){\r\n                this.setSlidePlayingStatus(false);\r\n            }else{\r\n                // 退出循环播放\r\n                if(this.currentIndex.get()==-1){\r\n                    this.currentIndex.set(this.imageUtilList.size()-1);\r\n                }\r\n\r\n                this.updateMainImageView();\r\n                this.setSlidePlayingStatus(true);\r\n                if(this.playingTimeLine!=null && this.zoomingTimeLine!=null){\r\n                    this.playingTimeLine.stop();\r\n                    this.zoomingTimeLine.stop();\r\n                }\r\n                // 退出全屏时的动画效果\r\n                FadeTransition ft = new FadeTransition(Duration.millis(500), rootPane);\r\n                ft.setFromValue(0.8);\r\n                ft.setToValue(1.0);\r\n                ft.play();\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * 导入图片及所在文件夹\r\n     * @param imageUtil 导入的图片信息工具\r\n     */\r\n    public void importImage(ImageUtil imageUtil) {\r\n        this.imageUtil = imageUtil;\r\n\r\n        File directory = imageUtil.getDirectory();\r\n        File[] images = directory.listFiles(FileUtil::isSupportImageFormat);\r\n        if (images != null) {\r\n            for (File image : images) {\r\n                ImageUtil imageFile = new ImageUtil(image);\r\n                this.imageUtilList.add(imageFile);\r\n            }\r\n        }\r\n\r\n        this.setUpZoomScaleListener();\r\n        this.setUpRotationListener();\r\n        this.initButtonStatus();\r\n        this.setUpMovementConstraints();\r\n\r\n        this.image = new Image(imageUtil.getURL());\r\n        this.updateMainImageView();\r\n    }\r\n\r\n    /**\r\n     * 图片信息面板\r\n     */\r\n    private ImageInfoPane imageInfoPane = new ImageInfoPane();\r\n    /**\r\n     * 信息面板容器\r\n     */\r\n    @FXML private HBox infoPane;\r\n\r\n    /**\r\n     * 显示图片信息面板\r\n     */\r\n    @FXML\r\n    private void showImageInfo(){\r\n        if(!this.imageInfoPane.isVisible()){\r\n            this.imageInfoPane.setVisible(true);\r\n        }else{\r\n            this.imageInfoPane.setVisible(false);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 初始化图片信息面板\r\n     */\r\n    private void initImageInfoPane() {\r\n        this.imageInfoPane.getStylesheets().setAll(getClass().getResource(\"/css/imageInfoPane.css\").toExternalForm());\r\n        this.imageInfoPane.setPrefWidth(320);\r\n        this.imageInfoPane.setPrefHeight(250);\r\n        this.infoPane.getChildren().add(this.imageInfoPane);\r\n        this.imageInfoPane.setVisible(false);\r\n    }\r\n    /**\r\n     * 旋转变换类\r\n     */\r\n    private Rotate rotateTransform = new Rotate(0);\r\n    /**\r\n     * 图片旋转\r\n     */\r\n    @FXML\r\n    private void rotate(){\r\n        this.recoverTranslattion(50);\r\n        rotateTransform.setAngle(rotateTransform.getAngle() + 90);\r\n        this.updateCursor();\r\n    }\r\n\r\n    /**\r\n     * 幻灯片混合播放\r\n     */\r\n    @FXML\r\n    public void playing(){\r\n        stage.setFullScreen(true);\r\n        this.playingTimeLine = new Timeline(new KeyFrame(Duration.millis(3000),e->{\r\n            nextImage(e);\r\n            // 循环播放\r\n            if(this.currentIndex.get() == this.imageUtilList.size() - 1){\r\n                this.currentIndex.set(-1);\r\n            }\r\n        }));\r\n        this.zoomingTimeLine = new Timeline(new KeyFrame(Duration.millis(100),e->{\r\n            if(this.MIN_SCALE<100){\r\n                this.zoom(1/1.01,null);\r\n            }else{\r\n                this.zoom(1.01,null);\r\n            }\r\n        }));\r\n\r\n        mainImageView.getScene().addEventFilter(KeyEvent.KEY_PRESSED,e->{\r\n            switch (e.getCode()){\r\n                case ESCAPE -> {\r\n\r\n                }\r\n                case SPACE -> {\r\n                    if(this.playingTimeLine.getStatus() == Animation.Status.PAUSED){\r\n                        this.playingTimeLine.play();\r\n                        this.zoomingTimeLine.play();\r\n                    }else{\r\n                        this.playingTimeLine.pause();\r\n                        this.zoomingTimeLine.pause();\r\n                    }\r\n                }\r\n            }\r\n\r\n        });\r\n\r\n        this.playingTimeLine.setCycleCount(Timeline.INDEFINITE);\r\n        this.playingTimeLine.play();\r\n        this.zoomingTimeLine.setCycleCount(Timeline.INDEFINITE);\r\n        this.zoomingTimeLine.play();\r\n    }\r\n\r\n    /**\r\n     * 顶部左功能栏\r\n     */\r\n    @FXML\r\n    private HBox topFunctionalColumn;\r\n\r\n    /**\r\n     * 顶部右窗口控制栏\r\n     */\r\n    @FXML\r\n    private HBox windowControlColumn;\r\n\r\n    /**\r\n     * 设置幻灯片播放界面其他组件可见性\r\n     * @param visible 可见性\r\n     */\r\n    private void setSlidePlayingStatus(boolean visible){\r\n        this.secondaryPane.setVisible(visible);\r\n        this.topFunctionalColumn.setVisible(visible);\r\n        this.windowControlColumn.setVisible(visible);\r\n        if(visible){\r\n            AnchorPane.setTopAnchor(this.imagePane,35.0);\r\n        }else{\r\n            AnchorPane.setTopAnchor(this.imagePane,0.0);\r\n        }\r\n    }\r\n\r\n//    private static final int MAX_VISIBLE_THUMBNAILS = 10;\r\n//    private static final double THUMBNAIL_WIDTH = 120;\r\n//\r\n//    // 添加缩略图的方法\r\n//    private void addThumbnail(Image image) {\r\n//        ImageView thumbnail = new ImageView(image);\r\n//        thumbnail.setFitHeight(90);\r\n//        thumbnail.setPreserveRatio(true);\r\n//        thumbnailContainer.getChildren().add(thumbnail);\r\n//\r\n//        // 当超过10个时启用固定宽度\r\n//        if (thumbnailContainer.getChildren().size() > MAX_VISIBLE_THUMBNAILS) {\r\n//            thumbnailContainer.setPrefWidth(MAX_VISIBLE_THUMBNAILS * THUMBNAIL_WIDTH);\r\n//        }\r\n//    }\r\n    /**\r\n     * 监听图片旋转中心\r\n     */\r\n    private void setUpRotationListener(){\r\n        // 监听ImageView的尺寸变化，设置旋转中心点\r\n        mainImageView.boundsInLocalProperty().addListener((obs, oldVal, newVal) -> {\r\n            double width = newVal.getWidth();\r\n            double height = newVal.getHeight();\r\n            if (width > 0 && height > 0) {\r\n                rotateTransform.setPivotX(width / 2); // 中心点X坐标\r\n                rotateTransform.setPivotY(height / 2); // 中心点Y坐标\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 初始化并监听左右切换图片按钮禁用状态\r\n     */\r\n    private void initButtonStatus(){\r\n        this.prePage.setDisable(this.currentIndex.get() <= 0);\r\n        this.nextPage.setDisable(this.currentIndex.get() >= imageUtilList.size() - 1);\r\n\r\n        // 待同步功能实现再进一步完善\r\n        this.currentIndex.addListener((obs,oldvalue,newvalue)->{\r\n            if(newvalue.intValue()<=0){\r\n                this.setMenuItemDisable(this.prePage,true);\r\n                this.setMenuItemDisable(this.nextPage,false);\r\n            } else if (newvalue.intValue()>=imageUtilList.size()-1) {\r\n                this.setMenuItemDisable(this.nextPage,true);\r\n                this.setMenuItemDisable(this.prePage,false);\r\n            }else{\r\n                this.setMenuItemDisable(this.prePage,false);\r\n                this.setMenuItemDisable(this.nextPage,false);\r\n            }\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * 初始化并监听放缩比例及功能禁用状态\r\n     */\r\n    private void setUpZoomScaleListener(){\r\n        this.scaleInteger.addListener((obs,oldvalue,newvalue)->{\r\n            if(newvalue.intValue()<=MIN_SCALE){\r\n                this.zoomOut.setDisable(true);\r\n                if(this.MIN_SCALE<100){\r\n                    this.displayMode = DisplayMode.FIT;\r\n                    this.updateOriginalSacleStyle();\r\n                }else{\r\n                    this.displayMode = DisplayMode.ORIGINAL;\r\n                    this.updateOriginalSacleStyle();\r\n                }\r\n            } else if (newvalue.intValue()>=MAX_SCALE) {\r\n                this.zoomIn.setDisable(true);\r\n            } else {\r\n                this.zoomIn.setDisable(false);\r\n                this.zoomOut.setDisable(false);\r\n            }\r\n            this.zoomScale.setText(newvalue.toString()+\"%\");\r\n        });\r\n    }\r\n\r\n    /**\r\n     * 更新图片自适应和原比例按钮样式\r\n     */\r\n    private void updateOriginalSacleStyle(){\r\n        switch (displayMode) {\r\n            case FIT->{\r\n                this.originalScale.getTooltip().setText(\"原始比例 | Ctrl+O\");\r\n            }\r\n            default->{\r\n                this.originalScale.getTooltip().setText(\"适应窗口 | Ctrl+F\");\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * 设置按钮对应的菜单项的禁用状态\r\n     * @param button 按钮\r\n     * @param disable 是否禁用\r\n     */\r\n    private void setMenuItemDisable(Button button,boolean disable){\r\n        button.setDisable(disable);\r\n        for(MenuItem item: this.moreMenu.getItems()){\r\n            if(item.getId().equals(button.getId())){\r\n                item.setDisable(disable);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 更新当前窗口显示的图片及相关信息\r\n     */\r\n    private void updateMainImageView() {\r\n        this.originalWidth = this.image.getWidth();\r\n        this.originalHeight = this.image.getHeight();\r\n        this.imageInfoPane.setImageUtil(this.imageUtil);\r\n        this.updateWindowInfo();\r\n        this.initImageScale();\r\n        this.mainImageView.setImage(this.image);\r\n        this.updateCursor();\r\n    }\r\n\r\n    /**\r\n     * 清空上次设置后遗留下的数据\r\n     */\r\n    private void clearImageTransforms(){\r\n        this.mainImageView.setScaleX(1.0);\r\n        this.mainImageView.setScaleY(1.0);\r\n        this.mainImageView.setTranslateX(0);\r\n        this.mainImageView.setTranslateY(0);\r\n        this.mainImageView.getTransforms().clear();\r\n        this.rotateTransform.setAngle(0);\r\n        this.totalScale = 1.0;\r\n    }\r\n\r\n    /**\r\n     * 图片自适应窗口大小更新放缩比例\r\n     */\r\n    private void initImageScale(){\r\n        this.clearImageTransforms();\r\n        mainImageView.getTransforms().add(rotateTransform);\r\n        double paneWidth = imagePane.getWidth();\r\n        double paneHeight = imagePane.getHeight();\r\n\r\n        // 图片比面板大图片自适应窗口\r\n        if(this.originalWidth>paneWidth || this.originalHeight>paneHeight){\r\n            this.setDisplayMode(DisplayMode.FIT);\r\n            this.MIN_SCALE = this.getAdaptedPercent(paneWidth, paneHeight);\r\n        }else{  // 图片比面板小原始比例\r\n            this.setDisplayMode(DisplayMode.ORIGINAL);\r\n            this.MIN_SCALE = 100;\r\n        }\r\n        this.scaleInteger.set(this.MIN_SCALE);\r\n\r\n        this.totalScale = 1.0;\r\n    }\r\n\r\n    /**\r\n     * 更新图片显示大小并绑定\r\n     */\r\n    private void updateImageSize() {\r\n        switch (displayMode) {\r\n            case FIT -> {\r\n                mainImageView.fitWidthProperty().bind(imagePane.widthProperty());\r\n                mainImageView.fitHeightProperty().bind(imagePane.heightProperty());\r\n            }\r\n            case ORIGINAL -> {\r\n\r\n                mainImageView.fitWidthProperty().bind(image.widthProperty());\r\n                mainImageView.fitHeightProperty().bind(image.heightProperty());\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置图片显示模式\r\n     * @param mode 显示模式\r\n     */\r\n    private void setDisplayMode(DisplayMode mode) {\r\n        displayMode = mode;\r\n        updateImageSize();\r\n    }\r\n\r\n    /**\r\n     * 根据图片显示模式更新\r\n     */\r\n    @FXML\r\n    private void updateOriginalScaleStatus(){\r\n        switch(displayMode){\r\n            case FIT -> {\r\n                this.setOriginalScale();\r\n                this.displayMode = DisplayMode.ORIGINAL;\r\n            }\r\n            default -> {\r\n                this.adaptScene();\r\n                this.displayMode = DisplayMode.FIT;\r\n            }\r\n        }\r\n        this.updateOriginalSacleStyle();\r\n    }\r\n\r\n    /**\r\n     * 图片适应窗口\r\n     */\r\n    private void adaptScene(){\r\n        int adaptedPercent = this.getAdaptedPercent(imagePane.getWidth(), imagePane.getHeight());\r\n        Timeline[] timelines = new Timeline[1];\r\n        if(adaptedPercent>this.scaleInteger.get()){\r\n            int curScale = this.MIN_SCALE;\r\n            timelines[0] = new Timeline(\r\n                    new KeyFrame(Duration.millis(10), event -> {\r\n                        zoomIn();\r\n                        if(curScale * totalScale >= adaptedPercent){\r\n                            timelines[0].stop();\r\n                            zoomOut();\r\n                        }\r\n                    })\r\n            );\r\n            timelines[0].setCycleCount(Timeline.INDEFINITE);\r\n            timelines[0].play();\r\n        }else if(adaptedPercent<this.scaleInteger.get() && this.MIN_SCALE<100){\r\n            int curScale = this.MIN_SCALE;\r\n            timelines[0] = new Timeline(\r\n                    new KeyFrame(Duration.millis(10), event -> {\r\n                        zoomOut();\r\n                        if(this.scaleInteger.get()==this.MIN_SCALE){\r\n                            timelines[0].stop();\r\n                        }\r\n                    })\r\n            );\r\n            timelines[0].setCycleCount(Timeline.INDEFINITE);\r\n            timelines[0].play();\r\n        }else{\r\n            int curScale = this.MIN_SCALE;\r\n            timelines[0] = new Timeline(\r\n                    new KeyFrame(Duration.millis(10), event -> {\r\n                        zoomOut();\r\n                        if(curScale * totalScale < adaptedPercent){\r\n                            timelines[0].stop();\r\n                        }\r\n                    })\r\n            );\r\n            timelines[0].setCycleCount(Timeline.INDEFINITE);\r\n            timelines[0].play();\r\n        }\r\n\r\n        this.scaleInteger.set(adaptedPercent);\r\n    }\r\n\r\n    /**\r\n     * 恢复图片原始比例\r\n     */\r\n    private void setOriginalScale(){\r\n        Timeline[] timelines = new Timeline[1];\r\n        if(this.MIN_SCALE < 100 && this.scaleInteger.get() < 100){\r\n            int curScale = this.MIN_SCALE;\r\n            timelines[0] = new Timeline(\r\n                    new KeyFrame(Duration.millis(10), event -> {\r\n                        zoomIn();\r\n                        if(curScale * totalScale >= 100){\r\n                            timelines[0].stop();\r\n                        }\r\n                    })\r\n            );\r\n            timelines[0].setCycleCount(Timeline.INDEFINITE);\r\n            timelines[0].play();\r\n        }else{\r\n            int curScale = this.MIN_SCALE;\r\n            timelines[0] = new Timeline(\r\n                    new KeyFrame(Duration.millis(10), event -> {\r\n                        zoomOut();\r\n                        if(this.scaleInteger.get()==this.MIN_SCALE){\r\n                            timelines[0].stop();\r\n                        }\r\n                    })\r\n            );\r\n            timelines[0].setCycleCount(Timeline.INDEFINITE);\r\n            timelines[0].play();\r\n        }\r\n    }\r\n\r\n\r\n    /**\r\n     * 计算图片自适应窗口后的缩小比例\r\n     * @param fitWidth imageview适应宽\r\n     * @param fitHeight imageview适应高\r\n     * @return 适应后的缩小比例\r\n     */\r\n    private int getAdaptedPercent(double fitWidth, double fitHeight) {\r\n//        double displayWidth = 0;\r\n//        double displayHeight = 0;\r\n//\r\n//        //按比例适应\r\n//        if (this.mainImageView.isPreserveRatio()) {\r\n//            double actualRatio = actualWidth / actualHeight;\r\n//            double fitRatio = fitWidth / fitHeight;\r\n//            if (actualRatio > fitRatio) {   //宽填满,高缩放\r\n//                displayWidth = fitWidth;\r\n//                displayHeight = fitWidth / actualRatio;\r\n//            } else {\r\n//                displayHeight = fitHeight;  //高填满,宽缩放\r\n//                displayWidth = fitHeight * actualRatio;\r\n//            }\r\n//        } else {  // 不按比例适应\r\n//            displayWidth = fitWidth;\r\n//            displayHeight = fitHeight;\r\n//        }\r\n//        int ScaleX = (int) (100 * displayWidth / actualWidth);\r\n//        int ScaleY = (int) (100 * displayHeight / actualHeight);\r\n//        return Math.min(ScaleX, ScaleY);\r\n        return (int)(100 * Math.min(fitWidth / originalWidth, fitHeight / originalHeight));\r\n    }\r\n\r\n//    private boolean isFilledImage(double actualWidth, double actualHeight, double fitWidth, double fitHeight){\r\n//        double displayWidth = 0;\r\n//        double displayHeight = 0;\r\n//\r\n//        //按比例适应\r\n//        if (this.mainImageView.isPreserveRatio()) {\r\n//            double actualRatio = actualWidth / actualHeight;\r\n//            double fitRatio = fitWidth / fitHeight;\r\n//            if (actualRatio > fitRatio) {   //宽填满,高缩放\r\n//                displayWidth = fitWidth;\r\n//                displayHeight = fitWidth / actualRatio;\r\n//            } else {\r\n//                displayHeight = fitHeight;  //高填满,宽缩放\r\n//                displayWidth = fitHeight * actualRatio;\r\n//            }\r\n//        } else {  // 不按比例适应\r\n//            displayWidth = fitWidth;\r\n//            displayHeight = fitHeight;\r\n//        }\r\n//\r\n//        return\r\n//    }\r\n\r\n    private double lastX, lastY;    // 拖拽前鼠标位置\r\n    private double translateX = 0 , translateY = 0;  // 当前偏移量\r\n\r\n    /**\r\n     * 图片恢复偏置\r\n     * @param ms 动画毫秒数\r\n     */\r\n    private void recoverTranslattion(double ms){\r\n        TranslateTransition transition = new TranslateTransition(Duration.millis(ms), mainImageView);\r\n        transition.setToX(0);\r\n        transition.setToY(0);\r\n        transition.play();\r\n        this.translateX =0;\r\n        this.translateY =0;\r\n    }\r\n\r\n    /**\r\n     * 设置鼠标拖拽移动事件,限制移动范围\r\n     */\r\n    private void setUpMovementConstraints() {\r\n        imagePane.setOnMousePressed(e -> {\r\n            if (e.getButton() == MouseButton.PRIMARY&&this.isMoveable()) {\r\n                lastX = e.getScreenX();\r\n                lastY = e.getScreenY();\r\n                this.imagePane.setCursor(Cursor.CLOSED_HAND);\r\n            }\r\n        });\r\n\r\n        imagePane.setOnMouseDragged(e -> {\r\n            if (e.getButton() == MouseButton.PRIMARY&&this.isMoveable()) {\r\n                this.imagePane.setCursor(Cursor.CLOSED_HAND);\r\n                Bounds currentBounds = this.mainImageView.getBoundsInParent();\r\n                Bounds stackVisibleBounds = imagePane.getLayoutBounds();\r\n                double imgPaneWidth = stackVisibleBounds.getWidth();\r\n                double imgPaneHeight = stackVisibleBounds.getHeight();\r\n                // 计算允许的移动方向\r\n                boolean widthFilled = currentBounds.getWidth() > imgPaneWidth;\r\n                boolean heightFilled = currentBounds.getHeight() > imgPaneHeight;\r\n\r\n                if(widthFilled){\r\n                    double deltaX = e.getScreenX() - lastX;\r\n                    // 应用限制后的偏移量\r\n                    translateX += widthFilled ? deltaX : 0;\r\n                    // 限制移动范围\r\n                    translateX = getFixedOffset(translateX,imgPaneWidth /2 - currentBounds.getWidth()/2, currentBounds.getWidth()/2 - imgPaneWidth/2);\r\n                    mainImageView.setTranslateX(translateX);\r\n                    lastX = e.getScreenX();\r\n                }\r\n                if(heightFilled){\r\n                    double deltaY = e.getScreenY() - lastY;\r\n                    translateY += heightFilled ? deltaY : 0;\r\n                    translateY = getFixedOffset(translateY, imgPaneHeight/2 - currentBounds.getHeight()/2, currentBounds.getHeight()/2 - imgPaneHeight/2);\r\n                    mainImageView.setTranslateY(translateY);\r\n                    lastY = e.getScreenY();\r\n                }\r\n            }\r\n        });\r\n\r\n        imagePane.setOnMouseReleased(e -> {\r\n            this.updateCursor();\r\n        });\r\n    }\r\n\r\n\r\n    /**\r\n     * 获得移动限制范围内的移动偏移量\r\n     * @param value 原始偏移值\r\n     * @param min 最小负偏移值\r\n     * @param max 最大正偏移值\r\n     * @return 修正偏移值\r\n     */\r\n    private double getFixedOffset(double value, double min, double max) {\r\n        return Math.max(min, Math.min(max, value));\r\n    }\r\n\r\n    /**\r\n     * 判断图片是否可移动视图\r\n     * @return 可移动值\r\n     */\r\n    private boolean isMoveable(){\r\n        Bounds currentBounds = this.mainImageView.getBoundsInParent();\r\n        Bounds stackVisibleBounds = imagePane.getLayoutBounds();\r\n        int imgPaneWidth = (int)stackVisibleBounds.getWidth();\r\n        int imgPaneHeight = (int)stackVisibleBounds.getHeight();\r\n        return (int)currentBounds.getWidth() > imgPaneWidth || (int)currentBounds.getHeight() > imgPaneHeight;\r\n    }\r\n    /**\r\n     * 判断图片是否已经填满场景\r\n     * @return 填满场景值\r\n     */\r\n    private boolean isOverflow(){\r\n        Bounds imageBounds = this.mainImageView.getBoundsInParent();\r\n        Bounds stackVisibleBounds = imagePane.getLayoutBounds();\r\n        return  (int)imageBounds.getWidth() >= (int)stackVisibleBounds.getWidth() && (int)imageBounds.getHeight() >= (int)stackVisibleBounds.getHeight();\r\n    }\r\n    //    private void addEdgeBounceEffect() {\r\n//        final double SPRING_CONSTANT = 0.05;\r\n//        final double FRICTION = 0.9;\r\n//\r\n//        imageView.translateXProperty().addListener((obs, old, newVal) -> {\r\n//            Bounds imgBounds = imageView.getBoundsInParent();\r\n//            Bounds viewport = container.getBoundsInLocal();\r\n//\r\n//            if (imgBounds.getWidth() > viewport.getWidth()) {\r\n//                double overflow = (imgBounds.getWidth() - viewport.getWidth())/2;\r\n//                if (Math.abs(newVal.doubleValue()) > overflow) {\r\n//                    double velocity = (newVal.doubleValue() - old.doubleValue()) * FRICTION;\r\n//                    animateRebound(overflow * Math.signum(newVal.doubleValue()), velocity, true);\r\n//                }\r\n//            }\r\n//        });\r\n//\r\n//        // Y轴同理\r\n//    }\r\n    /**\r\n     * 更新鼠标状态\r\n     */\r\n    private void updateCursor(){\r\n        if(this.isMoveable()){\r\n            imagePane.setCursor(Cursor.OPEN_HAND);\r\n        }else{\r\n            imagePane.setCursor(Cursor.DEFAULT);\r\n        }\r\n    }\r\n    /**\r\n     * 总放缩比例\r\n     */\r\n    private double totalScale = 1.0;\r\n    /**\r\n     * 放大因子\r\n     */\r\n    private final double zoomInFactor = 1.1;\r\n    /**\r\n     * 缩小因子\r\n     */\r\n    private final double zoomOutFactor = 1/1.1;\r\n    /**\r\n     * 放缩原子操作\r\n     * @param zoomFactor 放缩因子\r\n     * @param zoomCenter 放缩中心\r\n     */\r\n    private void zoom(double zoomFactor, Point2D zoomCenter) {\r\n        // 放缩值更新 以及 图片显示偏移值更新\r\n        double newSacle = this.totalScale * zoomFactor;\r\n        this.translateX *=zoomFactor;\r\n        this.translateY *=zoomFactor;\r\n        this.totalScale = newSacle;\r\n\r\n        // 先放缩\r\n        this.mainImageView.setScaleX(newSacle);\r\n        this.mainImageView.setScaleY(newSacle);\r\n\r\n        // 再偏移 (图片占满imagepane前先中心放缩,占满后偏移放缩)\r\n        if(zoomFactor>1&&this.isOverflow()){\r\n            this.mainImageView.setTranslateX(this.translateX);\r\n            this.mainImageView.setTranslateY(this.translateY);\r\n        }else if(zoomFactor<1&&this.isOverflow()){\r\n            Bounds currentBounds = this.mainImageView.getBoundsInParent();\r\n            double imgPaneWidth = this.imagePane.getLayoutBounds().getWidth();\r\n            double imgPaneHeight = this.imagePane.getLayoutBounds().getHeight();\r\n            // 限制偏移范围\r\n            translateX = getFixedOffset(translateX,imgPaneWidth /2 - currentBounds.getWidth()/2, currentBounds.getWidth()/2 - imgPaneWidth/2);\r\n            mainImageView.setTranslateX(translateX);\r\n            translateY = getFixedOffset(translateY, imgPaneHeight/2 - currentBounds.getHeight()/2, currentBounds.getHeight()/2 - imgPaneHeight/2);\r\n            mainImageView.setTranslateY(translateY);\r\n        }else{\r\n            this.recoverTranslattion(200);\r\n        }\r\n\r\n\r\n        // 值溢出修正\r\n        int newScaleInterger = Math.min((int) (this.MIN_SCALE * newSacle), this.MAX_SCALE);\r\n        newScaleInterger = Math.max(newScaleInterger, this.MIN_SCALE);\r\n        if(newScaleInterger == this.MIN_SCALE|| newScaleInterger == this.MAX_SCALE){\r\n            this.stopTimerLine();\r\n        }\r\n        // 更新比例值\r\n        this.scaleInteger.set(newScaleInterger);\r\n        // 更新是否可移动鼠标样式\r\n        this.updateCursor();\r\n    }\r\n\r\n    /**\r\n     * 中心放大\r\n     */\r\n    @FXML\r\n    private void zoomIn() {\r\n        this.zoom(this.zoomInFactor,null);\r\n    }\r\n\r\n    /**\r\n     * 持续中心放大\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void zoomInConstantly(Event event){\r\n        this.fireConstantly(e->this.zoomIn(),80);\r\n    }\r\n\r\n    /**\r\n     * 在轴点放大\r\n     * @param zoomCenter 轴点\r\n     */\r\n    private void zoomIn(Point2D zoomCenter){\r\n        this.zoom(this.zoomInFactor,zoomCenter);\r\n    }\r\n\r\n    /**\r\n     * 中心缩小\r\n     */\r\n    @FXML\r\n    private void zoomOut() {\r\n        this.zoom(this.zoomOutFactor,null);\r\n    }\r\n\r\n    /**\r\n     * 持续中心缩小\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void zoomOutConstantly(Event event){\r\n        this.fireConstantly(e->this.zoomOut(),80);\r\n    }\r\n\r\n    /**\r\n     * 在轴点缩小\r\n     * @param zoomCenter 轴点\r\n     */\r\n    private void zoomOut(Point2D zoomCenter) {\r\n        this.zoom(this.zoomOutFactor,zoomCenter);\r\n    }\r\n\r\n    /**\r\n     * 滚轮放缩移动图片\r\n     * @param scrollEvent\r\n     */\r\n    @FXML\r\n    private void zoomByScroll(ScrollEvent scrollEvent){\r\n        if(stage.isFullScreen()) return;                // 全屏屏蔽\r\n        if(scrollEvent.isControlDown()){\r\n            double deltaY = scrollEvent.getDeltaY();\r\n            if(deltaY>0){\r\n                if(this.scaleInteger.get()>=MAX_SCALE){\r\n                    return;\r\n                }\r\n                zoomIn(new Point2D(scrollEvent.getX(),scrollEvent.getY()));\r\n            }else{\r\n                if(this.scaleInteger.get()<=MIN_SCALE){\r\n                    return;\r\n                }\r\n                zoomOut(new Point2D(scrollEvent.getX(),scrollEvent.getY()));\r\n            }\r\n        }else{\r\n            Bounds currentBounds = this.mainImageView.getBoundsInParent();\r\n            Bounds stackVisibleBounds = imagePane.getLayoutBounds();\r\n            double imgPaneHeight = stackVisibleBounds.getHeight();\r\n            double imgPaneWidth = stackVisibleBounds.getWidth();\r\n            // 计算允许的移动方向\r\n            boolean heightFilled = currentBounds.getHeight() > imgPaneHeight;\r\n            boolean widthFilled = currentBounds.getWidth() > imgPaneWidth;\r\n            if(heightFilled){\r\n                double offset = scrollEvent.getDeltaY() > 0 ? 50 : -50;\r\n                translateY += heightFilled ? offset : 0;\r\n                translateY = getFixedOffset(translateY, imgPaneHeight/2 - currentBounds.getHeight()/2, currentBounds.getHeight()/2 - imgPaneHeight/2);\r\n                mainImageView.setTranslateY(translateY);\r\n            }else if(widthFilled){\r\n                double offset = scrollEvent.getDeltaY() > 0 ? 50 : -50;\r\n                translateX += widthFilled ? offset : 0;\r\n                translateX = getFixedOffset(translateX, imgPaneWidth/2 - currentBounds.getWidth()/2, currentBounds.getWidth()/2 - imgPaneWidth/2);\r\n                mainImageView.setTranslateX(translateX);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 更新窗口标题及图片相关信息\r\n     */\r\n    private void updateWindowInfo() {\r\n        String str = this.imageUtil.getFileName();\r\n        this.stage.setTitle(str);\r\n        this.imageName.setText(str);\r\n        this.updateControlTooltip(this.imageName,str,null);\r\n\r\n        str = String.format(\"%d/%d\",this.currentIndex.get()+1,this.imageUtilList.size());\r\n        this.orderNum.setText(str);\r\n        this.updateControlTooltip(this.orderNum,str,\"图片索引:\");\r\n\r\n        str = FileUtil.getFormatFileSize(this.imageUtil.getSizeOfBytes());\r\n        this.fileSize.setText(str);\r\n        this.updateControlTooltip(this.fileSize,str,\"图片大小:\");\r\n\r\n        str = String.format(\"%d×%d\",(int)this.image.getWidth(),(int)this.image.getHeight());\r\n        this.imageArea.setText(str);\r\n        this.updateControlTooltip(this.imageArea,str,\"图片尺寸:\");\r\n\r\n        // 图片比例\r\n        this.zoomScale.setText(this.scaleInteger.getValue().toString()+\"%\");\r\n        this.zoomOut.setDisable(this.scaleInteger.get() <= MIN_SCALE);\r\n    }\r\n\r\n    /**\r\n     * 更新控制组件的提示词\r\n     * @param control  控制组件\r\n     * @param tooltipText   提示文本\r\n     * @param extraStr  额外文本\r\n     */\r\n    private void updateControlTooltip(Control control, String tooltipText,String extraStr){\r\n        if(control.getTooltip()!=null){\r\n            if(extraStr!=null){\r\n                control.getTooltip().setText(extraStr+\" \"+tooltipText);\r\n            }else{\r\n                control.getTooltip().setText(tooltipText);\r\n            }\r\n        }else {\r\n            if(extraStr!=null){\r\n                control.setTooltip(new Tooltip(extraStr+\" \"+tooltipText));\r\n            }else{\r\n                control.setTooltip(new Tooltip(tooltipText));\r\n            }\r\n            control.getTooltip().setShowDelay(Duration.millis(500));\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 触发持续事件\r\n     * @param handler 单点击触发事件处理逻辑\r\n     * @param ms 间隔毫秒数\r\n     */\r\n    private void fireConstantly(EventHandler<ActionEvent> handler,double ms){\r\n        if (this.timeline != null)\r\n            this.timeline.stop();\r\n        this.timeline = new Timeline(new KeyFrame(Duration.millis(ms),handler));\r\n        this.timeline.setCycleCount(Timeline.INDEFINITE); // 无限循环\r\n        this.timeline.play();\r\n    }\r\n\r\n    /**\r\n     * 切换上一张图片\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void preImage(Event event) {\r\n        this.currentIndex.set(this.currentIndex.get()-1);\r\n        if(this.currentIndex.get()<=0){\r\n            this.currentIndex.set(0);\r\n            this.stopTimerLine();\r\n            this.showPageTip();\r\n        }\r\n        this.imageUtil = this.imageUtilList.get(this.currentIndex.get());\r\n        this.image = new Image(imageUtil.getURL());\r\n        this.updateMainImageView();\r\n    }\r\n\r\n    /**\r\n     * 持续切换上一张图片\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void preImageConstantly(Event event) {\r\n        this.fireConstantly(e->this.preImage(event),300);\r\n    }\r\n    /**\r\n     * 切换下一张图片\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void nextImage(Event event) {\r\n        this.currentIndex.set(this.currentIndex.get()+1);\r\n        if(this.currentIndex.get()>=this.imageUtilList.size()-1){\r\n            this.currentIndex.set(imageUtilList.size()-1);\r\n            this.stopTimerLine();\r\n            this.showPageTip();\r\n        }\r\n        this.imageUtil = this.imageUtilList.get(this.currentIndex.get());\r\n        this.image = new Image(imageUtil.getURL());\r\n        this.updateMainImageView();\r\n    }\r\n\r\n    /**\r\n     * 持续切换下一张图片\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void nextImageConstantly(Event event) {\r\n        this.fireConstantly(e->this.nextImage(event),300);\r\n    }\r\n    /**\r\n     * 停止持续事件的时间线\r\n     */\r\n    @FXML\r\n    private void stopTimerLine() {\r\n        if(this.timeline != null){\r\n            this.timeline.stop();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 显示页面范围提示\r\n     */\r\n    private void showPageTip(){\r\n        if(this.currentIndex.get()==0){\r\n            Notifications.create()\r\n                    .text(\"第一张\")\r\n                    .hideAfter(Duration.seconds(0.5))\r\n                    .position(Pos.CENTER)\r\n                    .owner(this.secondaryPane)\r\n                    .darkStyle()\r\n                    .show();\r\n\r\n        } else if (this.currentIndex.get() == this.imageUtilList.size()-1) {\r\n            Notifications.create()\r\n                    .text(\"最后一张\")\r\n                    .hideAfter(Duration.seconds(0.5))\r\n                    .position(Pos.CENTER)\r\n                    .owner(this.secondaryPane)\r\n                    .darkStyle()\r\n                    .show();\r\n\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 设置全局scene键盘事件\r\n     */\r\n    public void setUpKeyEvent(Scene scene){\r\n        Platform.runLater(() -> {\r\n            scene.addEventFilter(KeyEvent.KEY_PRESSED, event -> {\r\n                this.initShortcutKey(event);\r\n            });\r\n            scene.addEventFilter(KeyEvent.KEY_RELEASED, event -> {\r\n                this.stopTimerLine();\r\n            });\r\n        });\r\n\r\n    }\r\n\r\n    /**\r\n     * 初始化快捷键方法\r\n     * @param event\r\n     */\r\n    private void initShortcutKey(KeyEvent event){\r\n        if(stage.isFullScreen()) {\r\n            return;\r\n        }\r\n\r\n        KeyCode code = event.getCode();\r\n\r\n        if (event.isControlDown()) {\r\n            switch (code) {\r\n                case O -> {\r\n                    if(this.displayMode==DisplayMode.ORIGINAL){\r\n                        return;\r\n                    }\r\n                    this.displayMode = DisplayMode.FIT;\r\n                    this.updateOriginalScaleStatus();\r\n                }\r\n                case F -> {\r\n                    if(this.displayMode==DisplayMode.FIT){\r\n                        return;\r\n                    }\r\n                    this.displayMode = DisplayMode.ORIGINAL;\r\n                    this.updateOriginalScaleStatus();\r\n                }\r\n                case R-> {\r\n                    this.rotate();\r\n                }\r\n                case I->{\r\n                    this.showImageInfo();\r\n                }\r\n                case P->{\r\n                    this.playing();\r\n                }\r\n            }\r\n        }else{\r\n            switch(code){\r\n                case LEFT -> {              //左方向键\r\n                    if(this.currentIndex.get()<=0){\r\n                        event.consume();\r\n                    }else{\r\n                        preImage(event);\r\n                    }\r\n                }\r\n                case RIGHT -> {             //右方向键\r\n                    if(this.currentIndex.get()>=imageUtilList.size()-1){\r\n                        event.consume();\r\n                    }else{\r\n                        nextImage(event);\r\n                    }\r\n                }\r\n                case OPEN_BRACKET -> {      //左中括号\r\n                    if(this.scaleInteger.get()>=MAX_SCALE){\r\n                        event.consume();\r\n                    }else {\r\n                        zoomIn();\r\n                    }\r\n                }\r\n                case CLOSE_BRACKET -> {     //右中括号\r\n                    if(this.scaleInteger.get()<=MIN_SCALE){\r\n                        event.consume();\r\n                    }else{\r\n                        zoomOut();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n\r\n    /**\r\n     * 初始化图标url和提示文本映射关系\r\n     */\r\n    private void initMap(){\r\n        urlMap.put(\"moreMenuButton\", \"/icon/MoreMenu.png\");\r\n        urlMap.put(\"rotate\", \"/icon/rotate.png\");\r\n        urlMap.put(\"delete\", \"/icon/ashbin.png\");\r\n        urlMap.put(\"prePage\", \"/icon/arrow-left-circle.png\");\r\n        urlMap.put(\"nextPage\", \"/icon/arrow-right-circle.png\");\r\n        urlMap.put(\"play\", \"/icon/play.png\");\r\n        urlMap.put(\"info\", \"/icon/prompt.png\");\r\n        urlMap.put(\"compress\",  \"/icon/compress.png\");\r\n        urlMap.put(\"zoomIn\", \"/icon/zoom-in.png\");\r\n        urlMap.put(\"zoomOut\", \"/icon/zoom-out.png\");\r\n        urlMap.put(\"originalScale\",\"/icon/original-fit.png\");\r\n        urlMap.put(\"item1\",\"/icon/MoreMenu.png\");\r\n        urlMap.put(\"item2\",\"/icon/MoreMenu.png\");\r\n        urlMap.put(\"item3\",\"/icon/MoreMenu.png\");\r\n        textMap.put(\"moreMenuButton\", \"更多功能\");\r\n        textMap.put(\"rotate\", \"顺时针旋转90°|Ctrl+R\");\r\n        textMap.put(\"delete\", \"删除|Ctrl+D\");\r\n        textMap.put(\"prePage\", \"上一张|方向键⬅\");\r\n        textMap.put(\"nextPage\", \"下一张|方向键➡\");\r\n        textMap.put(\"play\", \"播放|Ctrl+P\");\r\n        textMap.put(\"info\", \"信息|Ctrl+I\");\r\n        textMap.put(\"compress\",  \"压缩|Ctrl+C\");\r\n        textMap.put(\"zoomIn\", \"放大|开括号[|Ctrl+滚轮⬆\");\r\n        textMap.put(\"zoomOut\", \"缩小|闭括号]|Ctrl+滚轮⬇\");\r\n        textMap.put(\"originalScale\",\"原始比例\");\r\n        textMap.put(\"minBtn\",\"最小化\");\r\n        textMap.put(\"maxBtn\",\"最大化\");\r\n        textMap.put(\"closeBtn\",\"关闭\");\r\n        textMap.put(\"item1\",\"选项1\");\r\n        textMap.put(\"item2\",\"选项2\");\r\n        textMap.put(\"item3\",\"选项3\");\r\n        buttonMap.put(\"rotate\",this.rotate );\r\n        buttonMap.put(\"delete\", this.delete );\r\n        buttonMap.put(\"prePage\",this.prePage );\r\n        buttonMap.put(\"nextPage\", this.nextPage);\r\n        buttonMap.put(\"play\", this.play);\r\n        buttonMap.put(\"info\", this.info);\r\n        buttonMap.put(\"compress\", this.compress);\r\n    }\r\n\r\n    /**\r\n     * 初始化顶部功能按钮样式,添加鼠标悬停文本提示,\r\n     */\r\n    private void initButtonStyle(){\r\n        Tooltip[] tooltips = {\r\n                new Tooltip(\"更多功能\"),\r\n                new Tooltip(\"顺时针旋转90°|Ctrl+R\"),\r\n                new Tooltip(\"删除|Ctrl+D\"),\r\n                new Tooltip(\"上一张|方向键⬅\"),\r\n                new Tooltip(\"下一张|方向键➡\"),\r\n                new Tooltip(\"播放|Ctrl+P\"),\r\n                new Tooltip(\"信息|Ctrl+I\"),\r\n                new Tooltip(\"压缩|Ctrl+C\"),\r\n                new Tooltip( \"放大|开括号[|Ctrl+滚轮⬆\"),\r\n                new Tooltip(\"缩小|闭括号]|Ctrl+滚轮⬇\"),\r\n                new Tooltip(\"原始比例\"),\r\n                new Tooltip(\"最小化\"),\r\n                new Tooltip(\"最大化\"),\r\n                new Tooltip(\"关闭\"),\r\n        };\r\n\r\n        // 文本提示弹窗延时\r\n        for(Tooltip tooltip : tooltips){\r\n            tooltip.setShowDelay(Duration.millis(500));\r\n        }\r\n\r\n        ObservableList<Node> children = dynamicButtonContainer.getChildren();\r\n        int size = children.size();\r\n        for (int i=0; i < size; i++) {\r\n            Button btn = (Button) children.get(i);\r\n            String style = String.format(\r\n                    \"-fx-background-image: url('%s');-fx-background-size: 20,20\",\r\n                    getClass().getResource(urlMap.get(btn.getId())).toExternalForm()\r\n            );\r\n\r\n            btn.setStyle(style);\r\n            btn.setTooltip(tooltips[i]);\r\n        }\r\n\r\n        // 基本固定不动的按钮,手动设置样式和文本提示\r\n        zoomIn.setStyle(String.format(\r\n                \"-fx-background-image: url('%s');-fx-background-size: 20,20\",\r\n                getClass().getResource(urlMap.get(\"zoomIn\")).toExternalForm()\r\n        ));\r\n        zoomIn.setTooltip(tooltips[8]);\r\n        zoomOut.setStyle(String.format(\r\n                \"-fx-background-image: url('%s');-fx-background-size: 20,20\",\r\n                getClass().getResource(urlMap.get(\"zoomOut\")).toExternalForm()\r\n        ));\r\n        zoomOut.setTooltip(tooltips[9]);\r\n        originalScale.setStyle(String.format(\r\n                \"-fx-background-image: url('%s');-fx-background-size: 20,20\",\r\n                getClass().getResource(urlMap.get(\"originalScale\")).toExternalForm()\r\n        ));\r\n        originalScale.setTooltip(tooltips[10]);\r\n        minBtn.setTooltip(tooltips[11]);\r\n        maxBtn.setTooltip(tooltips[12]);\r\n        closeBtn.setTooltip(tooltips[13]);\r\n\r\n\r\n    }\r\n\r\n\r\n\r\n    // 创建菜单项\r\n    private CustomMenuItem item1  =createMenuItem(\"选项1\",\"/icon/prompt.png\");\r\n    private CustomMenuItem item2  =createMenuItem(\"选项2\",\"/icon/prompt.png\");\r\n    private CustomMenuItem item3  =createMenuItem(\"选项3\",\"/icon/prompt.png\");\r\n    private ContextMenu moreMenu = new ContextMenu();\r\n    /**\r\n     * 菜单按钮初始化\r\n     */\r\n    private void initMoreMenuButton() {\r\n        item1.setId(\"item1\");\r\n        item2.setId(\"item2\");\r\n        item3.setId(\"item3\");\r\n        moreMenu.setAutoHide(true);\r\n        moreMenu.setAutoFix(true);\r\n        moreMenu.getItems().addAll(item1, item2, item3);\r\n        // 点击按钮切换菜单\r\n        moreMenuButton.setOnAction(e -> toggleMenu());\r\n    }\r\n\r\n    private CustomMenuItem createMenuItem(String text, String iconPath) {\r\n        ImageView icon = new ImageView(new Image(getClass().getResource(iconPath).toExternalForm()));\r\n        icon.setFitWidth(20);\r\n        icon.setFitHeight(20);\r\n        Label label = new Label(text);\r\n        HBox content = new HBox(2, icon, label);\r\n        content.setAlignment(Pos.CENTER_LEFT);\r\n        content.setSpacing(10);\r\n        CustomMenuItem item = new CustomMenuItem(content);\r\n        content.setPrefWidth(180);\r\n        item.setHideOnClick(true);\r\n        return item;\r\n    }\r\n\r\n\r\n    /**\r\n     * 在菜单按钮下方打开菜单\r\n     */\r\n    private void toggleMenu() {\r\n        if (moreMenu.isShowing()) {\r\n            moreMenu.hide();\r\n        } else {\r\n            // 计算按钮的屏幕坐标\r\n            Bounds bounds = moreMenuButton.localToScreen(moreMenuButton.getBoundsInLocal());\r\n            // 设置菜单位置（在按钮下方显示）\r\n            moreMenu.show(moreMenuButton, bounds.getMinX(), bounds.getMaxY());\r\n\r\n        }\r\n    }\r\n\r\n\r\n    // TODO 有精力再改进顶部信息栏地动态显示\r\n\r\n    /**\r\n     * 设置顶部功能按钮栏宽度监听器,用于动态显示功能按钮\r\n     */\r\n    private void setUpDynamicButtonContainerListener(){\r\n        dynamicButtonContainer.widthProperty().addListener((observableValue, oldValue, newValue) -> {this.adjustVisibleButtons();});\r\n    }\r\n\r\n\r\n    // TODO 修复BUG动态按钮被隐藏的时候再按全屏会出现顺序打乱的bug,改进算法,后续支持增加菜单按钮的默认按钮\r\n\r\n    /**\r\n     * 计算当前宽度下可以显示的按钮数量显示出来,多的隐藏到更多功能菜单里,后续能显示了再恢复出来\r\n     */\r\n    private void adjustVisibleButtons()  {\r\n        // 最多显示按钮数量\r\n        int MAX_BUTTON_NUM = 7;\r\n\r\n        // 计算可用宽度（容器宽度 - 菜单按钮宽度 - 边距-左右填充）\r\n        double availableWidth = dynamicButtonContainer.getWidth()\r\n                - moreMenuButton.getWidth()\r\n                - dynamicButtonContainer.getPadding().getLeft()\r\n                - dynamicButtonContainer.getPadding().getRight()\r\n                - dynamicButtonContainer.getSpacing();\r\n        // 每个按钮显示需要的宽度\r\n        double reqiredWidth =moreMenuButton.getPrefWidth() + dynamicButtonContainer.getSpacing();\r\n        List<Button> visibleButtons = new ArrayList<>();    // 放可以显示的按钮\r\n        List<Button> hiddenButtons = new ArrayList<>(); // 放需要隐藏的按钮\r\n        List<Button> preButtons = new ArrayList<>(); // 放初始时从菜单里转出来的按钮\r\n        double usedWidth = 0;\r\n\r\n        List<Node> actionButtons = dynamicButtonContainer.getChildren().subList(1, dynamicButtonContainer.getChildren().size());\r\n\r\n        // 先把更多功能菜单的菜单项导出来转成按钮,再进行后续处理\r\n        ObservableList<MenuItem> items = moreMenu.getItems();\r\n\r\n        if(items != null) {\r\n            for (MenuItem item : items) {\r\n                String id = item.getId();\r\n                Button btn = new Button();\r\n                btn.setId(id);\r\n                btn.setOnAction(item.getOnAction());\r\n                preButtons.add(btn);\r\n            }\r\n            items.clear();\r\n        }\r\n\r\n        // 计算可见按钮\r\n        for (Node btn : actionButtons) {\r\n            if (usedWidth + reqiredWidth <= availableWidth) {\r\n                usedWidth += reqiredWidth ;\r\n                visibleButtons.add(((Button)(btn)));\r\n            } else {\r\n                hiddenButtons.add(((Button)(btn)));\r\n            }\r\n        }\r\n\r\n        // 如果可以显示更多按钮则从菜单项拉出来的按钮再添加进去\r\n        if (usedWidth < availableWidth && visibleButtons.size() < MAX_BUTTON_NUM && !preButtons.isEmpty()) {\r\n            actionButtons.clear();\r\n            actionButtons.addAll(preButtons);\r\n\r\n            for (Node btn : actionButtons) {\r\n                if (usedWidth + reqiredWidth <= availableWidth && visibleButtons.size() < MAX_BUTTON_NUM) {\r\n                    usedWidth += reqiredWidth;\r\n                    visibleButtons.add(((Button) (btn)));\r\n                    preButtons.remove(((Button) (btn)));\r\n                }else{\r\n                    break;\r\n                }\r\n            }\r\n\r\n        }\r\n\r\n        // 更新容器显示\r\n        dynamicButtonContainer.getChildren().clear();\r\n        dynamicButtonContainer.getChildren().add(moreMenuButton);\r\n        for(Button btn : visibleButtons){\r\n            String id = btn.getId();\r\n            dynamicButtonContainer.getChildren().add(buttonMap.get(id));\r\n        }\r\n\r\n\r\n        // 更新弹出菜单内容\r\n        for(Button btn : hiddenButtons) {\r\n            String id = btn.getId();\r\n            CustomMenuItem item = this.createMenuItem(textMap.get(id),urlMap.get(id));\r\n            item.setId(id);\r\n            item.setOnAction(btn.getOnAction());\r\n            if(buttonMap.get(id)!=null&&buttonMap.get(id).isDisabled()){\r\n                item.setDisable(true);\r\n            }\r\n            items.add(item);\r\n        }\r\n\r\n        for (Button btn : preButtons) {\r\n            String id = btn.getId();\r\n            CustomMenuItem item = this.createMenuItem(textMap.get(id),urlMap.get(id));\r\n            item.setId(id);\r\n            item.setOnAction(btn.getOnAction());\r\n            if(buttonMap.get(id)!=null&&buttonMap.get(id).isDisabled()){\r\n                item.setDisable(true);\r\n            }\r\n            items.add(item);\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     *  窗口控制逻辑\r\n     */\r\n    private void setUpWindowControls() {\r\n        this.setUpResizeListeners();\r\n        maxBtn.getStyleClass().add(\"maxBtn-full\");\r\n        // 窗口控制按钮事件\r\n        closeBtn.setOnAction(e -> stage.close());\r\n        minBtn.setOnAction(e -> stage.setIconified(true));\r\n        maxBtn.setOnAction(e -> toggleMaximize());\r\n    }\r\n    /**\r\n     * 窗口最大化切换\r\n     */\r\n    private void toggleMaximize() {\r\n        stage.setMaximized(!stage.isMaximized());\r\n        if(stage.isMaximized()) {\r\n            maxBtn.getStyleClass().remove(\"maxBtn-full\");\r\n            maxBtn.getStyleClass().add(\"maxBtn-recover\");\r\n            maxBtn.getTooltip().setText(\"还原\");\r\n        }else {\r\n            maxBtn.getStyleClass().remove(\"maxBtn-recover\");\r\n            maxBtn.getStyleClass().add(\"maxBtn-full\");\r\n            maxBtn.getTooltip().setText(\"最大化\");\r\n        }\r\n    }\r\n\r\n\r\n\r\n    /**\r\n     * 窗口拖拽时的初始横坐标\r\n     */\r\n    private double startX;\r\n    /**\r\n     * 窗口拖拽时的初始纵坐标\r\n     */\r\n    private double startY;\r\n    /**\r\n     * 窗口拖拽前宽度\r\n     */\r\n    private double startWidth;\r\n    /**\r\n     * 窗口拖拽前高度\r\n     */\r\n    private double startHeight;\r\n\r\n    /**\r\n     * 顶部调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region topResize;\r\n    /**\r\n     * 底部调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region bottomResize;\r\n    /**\r\n     * 左边调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region leftResize;\r\n    /**\r\n     * 右边调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region rightResize;\r\n    /**\r\n     * 左上角调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region leftTopResize;\r\n    /**\r\n     * 右上角调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region rightTopResize;\r\n    /**\r\n     * 左下角调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region leftBottomResize;\r\n    /**\r\n     * 右下角调节窗口大小指示区域\r\n     */\r\n    @FXML\r\n    private Region rightBottomResize;\r\n    /**\r\n     * 根面板,锚定其他组件\r\n     */\r\n    @FXML\r\n    public AnchorPane rootPane;\r\n\r\n    /**\r\n     * 设置所有可调节窗口大小指示区域的监听器\r\n     */\r\n    private void setUpResizeListeners() {\r\n        // 左侧调整\r\n        setupResizeHandler(leftResize, ResizeDirection.LEFT);\r\n        // 右侧调整\r\n        setupResizeHandler(rightResize, ResizeDirection.RIGHT);\r\n        // 顶部调整\r\n        setupResizeHandler(topResize, ResizeDirection.TOP);\r\n        // 底部调整\r\n        setupResizeHandler(bottomResize, ResizeDirection.BOTTOM);\r\n        // 左上角调整\r\n        setupResizeHandler(leftTopResize, ResizeDirection.LEFT_TOP);\r\n        // 右上角调整\r\n        setupResizeHandler(rightTopResize, ResizeDirection.RIGHT_TOP);\r\n        // 左下角调整\r\n        setupResizeHandler(leftBottomResize, ResizeDirection.LEFT_BOTTOM);\r\n        // 右下角调整\r\n        setupResizeHandler(rightBottomResize, ResizeDirection.RIGHT_BOTTOM);\r\n    }\r\n\r\n    /**\r\n     * 鼠标拖拽事件分发处理逻辑\r\n     * @param region 调节区域\r\n     * @param direction 调节方向\r\n     */\r\n    private void setupResizeHandler(Region region, ResizeDirection direction) {\r\n        region.setOnMousePressed(event -> startResize(event));\r\n        region.setOnMouseDragged(event -> handleResize(event, direction));\r\n    }\r\n\r\n    /**\r\n     * 记录鼠标初始坐标,窗口初始大小\r\n     * @param event\r\n     */\r\n    private void startResize(MouseEvent event) {\r\n        startX = event.getScreenX();\r\n        startY = event.getScreenY();\r\n        startWidth = stage.getWidth();\r\n        startHeight = stage.getHeight();\r\n        event.consume();\r\n    }\r\n\r\n    /**\r\n     * 主要处理事件分发逻辑\r\n     * @param event\r\n     * @param direction 调节方向\r\n     */\r\n    private void handleResize(MouseEvent event, ResizeDirection direction) {\r\n        double deltaX = event.getScreenX() - startX;\r\n        double deltaY = event.getScreenY() - startY;\r\n\r\n        switch (direction) {\r\n            case LEFT:\r\n                handleLeftResize(deltaX);\r\n                break;\r\n            case RIGHT:\r\n                handleRightResize(deltaX);\r\n                break;\r\n            case TOP:\r\n                handleTopResize(deltaY);\r\n                break;\r\n            case BOTTOM:\r\n                handleBottomResize(deltaY);\r\n                break;\r\n            case LEFT_TOP:\r\n                handleLeftResize(deltaX);\r\n                handleTopResize(deltaY);\r\n                break;\r\n            case RIGHT_TOP:\r\n                handleRightResize(deltaX);\r\n                handleTopResize(deltaY);\r\n                break;\r\n            case LEFT_BOTTOM:\r\n                handleLeftResize(deltaX);\r\n                handleBottomResize(deltaY);\r\n                break;\r\n            case RIGHT_BOTTOM:\r\n                handleRightResize(deltaX);\r\n                handleBottomResize(deltaY);\r\n                break;\r\n        }\r\n        event.consume();\r\n    }\r\n\r\n    /**\r\n     * 原子调节操作,窗口在左边区域放缩\r\n     * @param deltaX x坐标偏移量\r\n     */\r\n    private void handleLeftResize(double deltaX) {\r\n        double newWidth = startWidth - deltaX;\r\n        if (newWidth > stage.getMinWidth()) {\r\n            stage.setWidth(newWidth);\r\n            stage.setX(startX + deltaX);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 原子调节操作,窗口在右边区域放缩\r\n     * @param deltaX x坐标偏移量\r\n     */\r\n    private void handleRightResize(double deltaX) {\r\n        double newWidth = startWidth + deltaX;\r\n        if (newWidth > stage.getMinWidth()) {\r\n            stage.setWidth(newWidth);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 原子调节操作,窗口在顶部区域放缩\r\n     * @param deltaY y坐标偏移量\r\n     */\r\n    private void handleTopResize(double deltaY) {\r\n        double newHeight = startHeight - deltaY;\r\n        if (newHeight > stage.getMinHeight()) {\r\n            stage.setHeight(newHeight);\r\n            stage.setY(startY + deltaY);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 原子调节操作,窗口在底部区域放缩\r\n     * @param deltaY y坐标偏移量\r\n     */\r\n    private void handleBottomResize(double deltaY) {\r\n        double newHeight = startHeight + deltaY;\r\n        if (newHeight > stage.getMinHeight()) {\r\n            stage.setHeight(newHeight);\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 调节方向枚举值\r\n     */\r\n    private enum ResizeDirection {\r\n        LEFT, RIGHT, TOP, BOTTOM,\r\n        LEFT_TOP, RIGHT_TOP, LEFT_BOTTOM, RIGHT_BOTTOM\r\n    }\r\n\r\n\r\n    private double xOffset = 0;\r\n    private double yOffset = 0;\r\n    /**\r\n     * 鼠标拖拽窗口事件处理,记录鼠标初始位置\r\n     */\r\n    @FXML\r\n    private void handleMousePressed(MouseEvent event) {\r\n        // 仅当点击在空白区域时记录坐标\r\n        if (event.getTarget() instanceof HBox) {\r\n            xOffset = event.getSceneX();\r\n            yOffset = event.getSceneY();\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 鼠标拖拽窗口事件处理,窗口跟随鼠标拖拽位置\r\n     * @param event\r\n     */\r\n    @FXML\r\n    private void handleMouseDragged(MouseEvent event) {\r\n        // 仅当初始点击在顶部功能栏上时执行拖拽\r\n        if (event.getTarget() instanceof HBox) {\r\n            stage.setX(event.getScreenX() - xOffset);\r\n            stage.setY(event.getScreenY() - yOffset);\r\n        }\r\n    }\r\n}\r\n\r\n\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/EIMP/src/main/java/com/eimp/controller/WindowSlideController.java b/EIMP/src/main/java/com/eimp/controller/WindowSlideController.java
--- a/EIMP/src/main/java/com/eimp/controller/WindowSlideController.java	(revision a261b5469fa131fe038c7af092b0e55f217c94b0)
+++ b/EIMP/src/main/java/com/eimp/controller/WindowSlideController.java	(date 1745496018598)
@@ -211,7 +211,7 @@
         this.setUpWindowControls();
         this.initImageInfoPane();
         this.setUpFullScreenListener();
-//        this.secondaryPane.setVisible(false);// 暂时隐藏缩略图栏,待实现
+        this.secondaryPane.setVisible(false);// 暂时隐藏缩略图栏,待实现
     }
 
     /**
Index: .idea/workspace.xml
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+><?xml version=\"1.0\" encoding=\"UTF-8\"?>\r\n<project version=\"4\">\r\n  <component name=\"AutoImportSettings\">\r\n    <option name=\"autoReloadType\" value=\"SELECTIVE\" />\r\n  </component>\r\n  <component name=\"ChangeListManager\">\r\n    <list default=\"true\" id=\"5131d40a-f0c4-48a5-9cf6-27261ba6054f\" name=\"Changes\" comment=\"修改jpg等图像裁剪无法保存bug,统一存储为png副本\">\r\n      <change beforePath=\"$PROJECT_DIR$/.idea/workspace.xml\" beforeDir=\"false\" afterPath=\"$PROJECT_DIR$/.idea/workspace.xml\" afterDir=\"false\" />\r\n    </list>\r\n    <option name=\"SHOW_DIALOG\" value=\"false\" />\r\n    <option name=\"HIGHLIGHT_CONFLICTS\" value=\"true\" />\r\n    <option name=\"HIGHLIGHT_NON_ACTIVE_CHANGELIST\" value=\"false\" />\r\n    <option name=\"LAST_RESOLUTION\" value=\"IGNORE\" />\r\n  </component>\r\n  <component name=\"FileTemplateManagerImpl\">\r\n    <option name=\"RECENT_TEMPLATES\">\r\n      <list>\r\n        <option value=\"FxmlFile\" />\r\n        <option value=\"CSS File\" />\r\n        <option value=\"Class\" />\r\n      </list>\r\n    </option>\r\n  </component>\r\n  <component name=\"Git.Settings\">\r\n    <option name=\"RECENT_GIT_ROOT_PATH\" value=\"$PROJECT_DIR$\" />\r\n  </component>\r\n  <component name=\"MavenImportPreferences\">\r\n    <option name=\"generalSettings\">\r\n      <MavenGeneralSettings>\r\n        <option name=\"mavenHomeTypeForPersistence\" value=\"WRAPPER\" />\r\n      </MavenGeneralSettings>\r\n    </option>\r\n  </component>\r\n  <component name=\"ProjectColorInfo\">{\r\n  &quot;associatedIndex&quot;: 5\r\n}</component>\r\n  <component name=\"ProjectId\" id=\"2u1TEXSu4zgxhCEzTp466mBO6YF\" />\r\n  <component name=\"ProjectLevelVcsManager\">\r\n    <ConfirmationsSetting value=\"2\" id=\"Add\" />\r\n  </component>\r\n  <component name=\"ProjectViewState\">\r\n    <option name=\"hideEmptyMiddlePackages\" value=\"true\" />\r\n    <option name=\"showLibraryContents\" value=\"true\" />\r\n  </component>\r\n  <component name=\"PropertiesComponent\">{\r\n  &quot;keyToString&quot;: {\r\n    &quot;ASKED_ADD_EXTERNAL_FILES&quot;: &quot;true&quot;,\r\n    &quot;ASKED_SHARE_PROJECT_CONFIGURATION_FILES&quot;: &quot;true&quot;,\r\n    &quot;Application.JavaFx.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.SlideWindow.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.Slide_test.executor&quot;: &quot;Run&quot;,\r\n    &quot;Application.Slide_testW.executor&quot;: &quot;Run&quot;,\r\n    &quot;Downloaded.Files.Path.Enabled&quot;: &quot;false&quot;,\r\n    &quot;Maven.EIMP [clean].executor&quot;: &quot;Run&quot;,\r\n    &quot;Repository.Attach.Annotations&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.JavaDocs&quot;: &quot;false&quot;,\r\n    &quot;Repository.Attach.Sources&quot;: &quot;false&quot;,\r\n    &quot;RunOnceActivity.ShowReadmeOnStart&quot;: &quot;true&quot;,\r\n    &quot;git-widget-placeholder&quot;: &quot;main&quot;,\r\n    &quot;jdk.selected.JAVA_MODULE&quot;: &quot;22&quot;,\r\n    &quot;kotlin-language-version-configured&quot;: &quot;true&quot;,\r\n    &quot;last_opened_file_path&quot;: &quot;D:/code/GitHub项目/EIMP&quot;,\r\n    &quot;list.type.of.created.stylesheet&quot;: &quot;CSS&quot;,\r\n    &quot;node.js.detected.package.eslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.detected.package.tslint&quot;: &quot;true&quot;,\r\n    &quot;node.js.selected.package.eslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;node.js.selected.package.tslint&quot;: &quot;(autodetect)&quot;,\r\n    &quot;nodejs_package_manager_path&quot;: &quot;npm&quot;,\r\n    &quot;project.structure.last.edited&quot;: &quot;模块&quot;,\r\n    &quot;project.structure.proportion&quot;: &quot;0.15&quot;,\r\n    &quot;project.structure.side.proportion&quot;: &quot;0.2&quot;,\r\n    &quot;settings.editor.selected.configurable&quot;: &quot;File.Encoding&quot;,\r\n    &quot;vue.rearranger.settings.migration&quot;: &quot;true&quot;,\r\n    &quot;应用程序.App.executor&quot;: &quot;Run&quot;,\r\n    &quot;应用程序.JavaFx.executor&quot;: &quot;Run&quot;\r\n  }\r\n}</component>\r\n  <component name=\"RecentsManager\">\r\n    <key name=\"ExtractSuperBase.RECENT_KEYS\">\r\n      <recent name=\"com.eimp.component\" />\r\n    </key>\r\n  </component>\r\n  <component name=\"RunManager\" selected=\"Application.JavaFx\">\r\n    <configuration name=\"JavaFx\" type=\"Application\" factoryName=\"Application\">\r\n      <option name=\"ALTERNATIVE_JRE_PATH\" value=\"22\" />\r\n      <option name=\"ALTERNATIVE_JRE_PATH_ENABLED\" value=\"true\" />\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"com.eimp.App\" />\r\n      <module name=\"EIMP\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration name=\"SlideWindow\" type=\"Application\" factoryName=\"Application\" temporary=\"true\" nameIsGenerated=\"true\">\r\n      <option name=\"MAIN_CLASS_NAME\" value=\"com.eimp.SlideWindow\" />\r\n      <module name=\"EIMP\" />\r\n      <extension name=\"coverage\">\r\n        <pattern>\r\n          <option name=\"PATTERN\" value=\"com.eimp.*\" />\r\n          <option name=\"ENABLED\" value=\"true\" />\r\n        </pattern>\r\n      </extension>\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"JetRunConfigurationType\">\r\n      <module name=\"-glcx\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n    <configuration default=\"true\" type=\"KotlinStandaloneScriptRunConfigurationType\">\r\n      <module name=\"-glcx\" />\r\n      <option name=\"filePath\" />\r\n      <method v=\"2\">\r\n        <option name=\"Make\" enabled=\"true\" />\r\n      </method>\r\n    </configuration>\r\n  </component>\r\n  <component name=\"SharedIndexes\">\r\n    <attachedChunks>\r\n      <set>\r\n        <option value=\"bundled-jdk-9f38398b9061-18abd8497189-intellij.indexing.shared.core-IU-241.14494.240\" />\r\n        <option value=\"bundled-js-predefined-1d06a55b98c1-74d2a5396914-JavaScript-IU-241.14494.240\" />\r\n      </set>\r\n    </attachedChunks>\r\n  </component>\r\n  <component name=\"SpellCheckerSettings\" RuntimeDictionaries=\"0\" Folders=\"0\" CustomDictionaries=\"0\" DefaultDictionary=\"application-level\" UseSingleDictionary=\"true\" transferred=\"true\" />\r\n  <component name=\"TaskManager\">\r\n    <task active=\"true\" id=\"Default\" summary=\"Default task\">\r\n      <changelist id=\"5131d40a-f0c4-48a5-9cf6-27261ba6054f\" name=\"Changes\" comment=\"\" />\r\n      <created>1741414969330</created>\r\n      <option name=\"number\" value=\"Default\" />\r\n      <option name=\"presentableId\" value=\"Default\" />\r\n      <updated>1741414969330</updated>\r\n      <workItem from=\"1741414970387\" duration=\"148000\" />\r\n      <workItem from=\"1741415238474\" duration=\"78000\" />\r\n      <workItem from=\"1741415322781\" duration=\"817000\" />\r\n      <workItem from=\"1741416163186\" duration=\"15000\" />\r\n      <workItem from=\"1741533717237\" duration=\"91000\" />\r\n      <workItem from=\"1741534242268\" duration=\"59000\" />\r\n      <workItem from=\"1741534601248\" duration=\"636000\" />\r\n      <workItem from=\"1741584919889\" duration=\"1722000\" />\r\n      <workItem from=\"1741589409844\" duration=\"2593000\" />\r\n      <workItem from=\"1741594378150\" duration=\"3074000\" />\r\n      <workItem from=\"1741616219711\" duration=\"1567000\" />\r\n      <workItem from=\"1742024272093\" duration=\"13301000\" />\r\n      <workItem from=\"1742088472055\" duration=\"63317000\" />\r\n      <workItem from=\"1742285121257\" duration=\"30344000\" />\r\n      <workItem from=\"1742383817151\" duration=\"5567000\" />\r\n      <workItem from=\"1742470433842\" duration=\"3808000\" />\r\n      <workItem from=\"1742719823386\" duration=\"12792000\" />\r\n      <workItem from=\"1743307299314\" duration=\"155000\" />\r\n      <workItem from=\"1743312089432\" duration=\"26694000\" />\r\n      <workItem from=\"1743384995330\" duration=\"7074000\" />\r\n      <workItem from=\"1743394356008\" duration=\"4014000\" />\r\n      <workItem from=\"1743422585214\" duration=\"3074000\" />\r\n      <workItem from=\"1743593950898\" duration=\"4442000\" />\r\n      <workItem from=\"1744444498749\" duration=\"7113000\" />\r\n      <workItem from=\"1745077384154\" duration=\"3830000\" />\r\n      <workItem from=\"1745113317771\" duration=\"1281000\" />\r\n      <workItem from=\"1745119468842\" duration=\"32000\" />\r\n      <workItem from=\"1745119541347\" duration=\"5701000\" />\r\n      <workItem from=\"1745415661916\" duration=\"693000\" />\r\n    </task>\r\n    <task id=\"LOCAL-00001\" summary=\"修改幻灯片UI,大部分已修改,缩略图UI待确定\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742387682241</created>\r\n      <option name=\"number\" value=\"00001\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00001\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742387682241</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00002\" summary=\"修改幻灯片UI,大部分已修改,缩略图UI待确定\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742387769800</created>\r\n      <option name=\"number\" value=\"00002\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00002\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742387769800</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00003\" summary=\"主窗口双击进入幻灯片接口完成,可以左右切换图片,其他功能待实现\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742724409529</created>\r\n      <option name=\"number\" value=\"00003\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00003\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742724409529</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00004\" summary=\"修改动态功能栏bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742740132715</created>\r\n      <option name=\"number\" value=\"00004\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00004\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742740132715</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00005\" summary=\"修改动态功能栏bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1742741665115</created>\r\n      <option name=\"number\" value=\"00005\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00005\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1742741665115</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00006\" summary=\"修改动态功能栏bug\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1743307038423</created>\r\n      <option name=\"number\" value=\"00006\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00006\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1743307038423</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00007\" summary=\"修改幻灯片图片无法适应窗口bug,更新图片旋转功能和相关快捷键方式\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1743324223185</created>\r\n      <option name=\"number\" value=\"00007\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00007\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1743324223185</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00008\" summary=\"新增幻灯片窗口查看图片信息及其相关操作功能,幻灯片播放功能\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744450357873</created>\r\n      <option name=\"number\" value=\"00008\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00008\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744450357873</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00009\" summary=\"新增幻灯片窗口查看图片信息及其相关操作功能,幻灯片播放功能\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1744450639933</created>\r\n      <option name=\"number\" value=\"00009\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00009\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1744450639933</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00010\" summary=\"新增图片裁剪功能,主界面幻灯片播放功能\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745112307071</created>\r\n      <option name=\"number\" value=\"00010\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00010\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745112307071</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00011\" summary=\"新增图片裁剪功能,主界面幻灯片播放功能\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745112358153</created>\r\n      <option name=\"number\" value=\"00011\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00011\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745112358153</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00012\" summary=\"修改jpg等图像裁剪无法保存bug,统一存储为png副本\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745126426351</created>\r\n      <option name=\"number\" value=\"00012\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00012\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745126426351</updated>\r\n    </task>\r\n    <task id=\"LOCAL-00013\" summary=\"修改jpg等图像裁剪无法保存bug,统一存储为png副本\">\r\n      <option name=\"closed\" value=\"true\" />\r\n      <created>1745126469031</created>\r\n      <option name=\"number\" value=\"00013\" />\r\n      <option name=\"presentableId\" value=\"LOCAL-00013\" />\r\n      <option name=\"project\" value=\"LOCAL\" />\r\n      <updated>1745126469031</updated>\r\n    </task>\r\n    <option name=\"localTasksCounter\" value=\"14\" />\r\n    <servers />\r\n  </component>\r\n  <component name=\"TypeScriptGeneratedFilesManager\">\r\n    <option name=\"version\" value=\"3\" />\r\n  </component>\r\n  <component name=\"Vcs.Log.Tabs.Properties\">\r\n    <option name=\"TAB_STATES\">\r\n      <map>\r\n        <entry key=\"MAIN\">\r\n          <value>\r\n            <State />\r\n          </value>\r\n        </entry>\r\n      </map>\r\n    </option>\r\n  </component>\r\n  <component name=\"VcsManagerConfiguration\">\r\n    <option name=\"ADD_EXTERNAL_FILES_SILENTLY\" value=\"true\" />\r\n    <MESSAGE value=\"修改幻灯片UI,大部分已修改,缩略图UI待确定\" />\r\n    <MESSAGE value=\"主窗口双击进入幻灯片接口完成,可以左右切换图片,其他功能待实现\" />\r\n    <MESSAGE value=\"更新幻灯片窗口图片放缩功能\" />\r\n    <MESSAGE value=\"修改动态功能栏bug\" />\r\n    <MESSAGE value=\"修改幻灯片图片无法适应窗口bug,更新图片旋转功能和相关快捷键方式\" />\r\n    <MESSAGE value=\"新增幻灯片窗口查看图片信息及其相关操作功能,幻灯片播放功能\" />\r\n    <MESSAGE value=\"新增图片裁剪功能,主界面幻灯片播放功能\" />\r\n    <MESSAGE value=\"修改jpg等图像裁剪无法保存bug,统一存储为png副本\" />\r\n    <option name=\"LAST_COMMIT_MESSAGE\" value=\"修改jpg等图像裁剪无法保存bug,统一存储为png副本\" />\r\n  </component>\r\n  <component name=\"XDebuggerManager\">\r\n    <watches-manager>\r\n      <configuration name=\"Application\">\r\n        <watch expression=\"file\" />\r\n      </configuration>\r\n    </watches-manager>\r\n  </component>\r\n</project>
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/.idea/workspace.xml b/.idea/workspace.xml
--- a/.idea/workspace.xml	(revision a261b5469fa131fe038c7af092b0e55f217c94b0)
+++ b/.idea/workspace.xml	(date 1745552785256)
@@ -6,6 +6,7 @@
   <component name="ChangeListManager">
     <list default="true" id="5131d40a-f0c4-48a5-9cf6-27261ba6054f" name="Changes" comment="修改jpg等图像裁剪无法保存bug,统一存储为png副本">
       <change beforePath="$PROJECT_DIR$/.idea/workspace.xml" beforeDir="false" afterPath="$PROJECT_DIR$/.idea/workspace.xml" afterDir="false" />
+      <change beforePath="$PROJECT_DIR$/EIMP/src/main/java/com/eimp/controller/WindowSlideController.java" beforeDir="false" afterPath="$PROJECT_DIR$/EIMP/src/main/java/com/eimp/controller/WindowSlideController.java" afterDir="false" />
     </list>
     <option name="SHOW_DIALOG" value="false" />
     <option name="HIGHLIGHT_CONFLICTS" value="true" />
@@ -162,6 +163,9 @@
       <workItem from="1745119468842" duration="32000" />
       <workItem from="1745119541347" duration="5701000" />
       <workItem from="1745415661916" duration="693000" />
+      <workItem from="1745489454227" duration="1507000" />
+      <workItem from="1745495734438" duration="671000" />
+      <workItem from="1745504041004" duration="1015000" />
     </task>
     <task id="LOCAL-00001" summary="修改幻灯片UI,大部分已修改,缩略图UI待确定">
       <option name="closed" value="true" />
@@ -267,7 +271,15 @@
       <option name="project" value="LOCAL" />
       <updated>1745126469031</updated>
     </task>
-    <option name="localTasksCounter" value="14" />
+    <task id="LOCAL-00014" summary="修改jpg等图像裁剪无法保存bug,统一存储为png副本">
+      <option name="closed" value="true" />
+      <created>1745489489132</created>
+      <option name="number" value="00014" />
+      <option name="presentableId" value="LOCAL-00014" />
+      <option name="project" value="LOCAL" />
+      <updated>1745489489132</updated>
+    </task>
+    <option name="localTasksCounter" value="15" />
     <servers />
   </component>
   <component name="TypeScriptGeneratedFilesManager">
